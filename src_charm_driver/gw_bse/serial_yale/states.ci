// A module defining the various messages that are shared between modules
module messages {
  // A message used to package and send around psi arrays
  message PsiMessage {
    complex psi[];
  };
};

module controller {
  extern module messages;
  readonly CProxy_Controller controller_proxy;
  readonly CProxy_PsiCache psi_cache_proxy;

  // Controls the coordination between the states, pmatrix, and cache based on
  // the configuration of pipeline depth, number of stages, etc.
  chare Controller {
    entry Controller();
    entry [reductiontarget] void cachesFilled();
    entry [reductiontarget] void psiComplete();
    entry [reductiontarget] void fftComplete();
    entry [reductiontarget] void transposeComplete();
    entry [reductiontarget] void printingComplete();

    entry void run() {
      // Tell the occupied psis to duplicate them in the cache, the wait for
      // the caches to report that they have been filled.
      for (next_K = 0; next_K < K; next_K++) {
        for (next_state = 0; next_state < L; next_state++) {
          serial { states_proxy(0, next_K, next_state).sendToCache(); }
        }
      }
      when cachesFilled() serial {}

      // Tell the unoccupised psis to send themselves to P, sending the first
      // chunk in the pipeline without waiting for any to complete.
      for (next_K = 0; next_K < K; next_K++) {
        for (next_state = L; next_state < L + M; next_state++) {
          serial {
            states_proxy(0, next_K, next_state).sendToP();
            total_sent++;
          }
          if (total_sent >= pipeline_stages) {
            when psiComplete() serial { total_complete++; }
          }
        }
      }
      while (total_complete < K * M) {
        when psiComplete() serial { total_complete++; }
      }

      serial { pmatrix_proxy.printRows(4, "P_Rspace"); }
      when printingComplete()   serial { pmatrix_proxy.fftRows(); }
      when fftComplete()        serial { pmatrix_proxy.printRows(4, "1FFT"); }
      when printingComplete()   serial { pmatrix_proxy.doTranspose(); }
      when transposeComplete()  serial { pmatrix_proxy.fftRows(); }
      when fftComplete()        serial { pmatrix_proxy.printRows(4, "2FFT"); }
      when printingComplete()   serial { pmatrix_proxy.doTranspose(); }
      when transposeComplete()  serial { pmatrix_proxy.printRows(4, "P_Gspace"); }
      when printingComplete()   serial { CkExit(); }
    }
  };

  // Caches psis locally on each node so they can be reused when forming P
  nodegroup PsiCache {
    entry PsiCache();
    entry void receivePsi(PsiMessage*);
  };
};

module states {
readonly CProxy_States states_proxy;

  // An array containing all of the states in the system. After reading in the
  // states and performing an initial FFT it waits for the controller to tell it
  // where and when to send its data.
  array [3D] States {
    entry States();
    entry [reductiontarget] void sendToCache();
    entry [reductiontarget] void sendToP();
  };  
};

module pmatrix {
  include "ckcomplex.h";
  extern module messages;
  readonly CProxy_PMatrix pmatrix_proxy;

  // An array containing a distributed representation of P. Each time it
  // receives a psi, it multiplies that psi against cached psis to incrementally
  // compute its values.
  array [1D] PMatrix {
    entry PMatrix();
    entry [nokeep] void receivePsi(PsiMessage*);
    entry void fftRows();
    entry void receiveTransposeData(int, complex);
    entry void printRows(int n, char prefix[16]);

    entry void doTranspose() {
      serial {
        for (int i = 0; i < num_cols; i++) {
          if (i == thisIndex) continue;
          thisProxy[i].receiveTransposeData(thisIndex, data[0][i]);
        }
      }
      for (trans_count = 0; trans_count < num_cols - 1; trans_count++) {
        when receiveTransposeData(int new_col, complex element) serial {
          data[0][new_col] = element;
        }
      }
      serial {
        contribute(CkCallback(CkReductionTarget(Controller, transposeComplete), controller_proxy));
      }
    }
  };
};
