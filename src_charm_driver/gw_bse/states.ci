// A module defining the various messages that are shared between modules
module messages {
  // A message used to package and send around psi arrays
  message PsiMessage {
    complex psi[];
  };

  // A message containing data being moved during a transpose
  message TransposeMessage {
    complex data[];
  };

  message Phase2Message {
    complex data[];
  };
};

module controller {
  extern module messages;
  extern module phase2;
  readonly CProxy_Controller controller_proxy;
  readonly CProxy_FFTController fft_controller_proxy;
  readonly CProxy_PsiCache psi_cache_proxy;
  initnode void init_plan_lock();

  // Controls the coordination between the states, pmatrix, and cache based on
  // the configuration of pipeline depth, number of stages, etc.
  chare Controller {
    entry Controller();
    entry [reductiontarget] void fftControllerReady();
    entry [reductiontarget] void stateFFTComplete();
    entry [reductiontarget] void cachesFilled();
    entry [reductiontarget] void psiComplete();
    entry [reductiontarget] void fftComplete();
    entry [reductiontarget] void transposeComplete();
    entry [reductiontarget] void printingComplete();
    entry [reductiontarget] void dataSendComplete();
    entry [reductiontarget] void phase2_complete();

    entry void run() {
      when fftControllerReady() serial {
        start = CmiWallTimer();
        CkPrintf("[CONTROLLER] Starting the controller @%f\n", start);
        states_proxy.fftGtoR();
      }

      when stateFFTComplete() serial {
        end = CmiWallTimer();
        CkPrintf("[CONTROLLER] States FFTd @%f (elapsed %f)\n", end, end - start);
        start = CmiWallTimer();
      }

      // Tell the occupied psis to duplicate them in the cache, the wait for
      // the caches to report that they have been filled.
      for (next_K = 0; next_K < K; next_K++) {
        for (next_state = 0; next_state < L; next_state++) {
          serial { states_proxy(0, next_K, next_state).sendToCache(); }
        }
      }
      when cachesFilled() serial {
        end = CmiWallTimer();
        CkPrintf("[CONTROLLER] Caches filled @%f (%f elapsed)\n", end, end - start);
        start = CmiWallTimer();
      }

      // Tell the unoccupised psis to send themselves to P, sending the first
      // chunk in the pipeline without waiting for any to complete.
      for (next_K = 0; next_K < K && total_sent < debug_stages; next_K++) {
        for (next_state = L; next_state < L + M && total_sent < debug_stages; next_state++) {
          serial {
            states_proxy(0, next_K, next_state).sendToComputeF();
            total_sent++;
          }
          if (total_sent >= pipeline_stages) {
            when psiComplete() serial { total_complete++; }
          }
        }
      }
      while (total_complete < K * M && total_complete < debug_stages) {
        when psiComplete() serial { total_complete++; }
      }

      serial {
        end = CmiWallTimer();
        CkPrintf("[CONTROLLER] P Formed in real space @%f (%f elapsed).\n", end, end - start);
        start = CmiWallTimer();
      }

      if (do_output) {
        // serial { pmatrix_proxy.printRows(4, "P_Rspace"); }
      }
      serial { 
        pmatrix_proxy.send_to_1d();
      }
      when dataSendComplete() serial{
        end = CmiWallTimer();
        CkPrintf("[PMATRIX] data is sent to 1d decomposition @%f (%f elapsed)\n", end, end - start);
        start = CmiWallTimer();
        phase2_proxy.fftRows(1);
      }
      when fftComplete() serial{
        CkPrintf("[PHASE2] fft #1 is done\n");
        phase2_proxy.doTranspose();

      }
      when transposeComplete() serial{
        CkPrintf("[PHASE2] transpose #1 is done\n");
        phase2_proxy.fftRows(-1);
      }
      when fftComplete() serial{
        CkPrintf("[PHASE2] fft #2 is done\n");
        phase2_proxy.doTranspose();
      }
      when transposeComplete() serial{
        CkPrintf("[PHASE2] transpose #2 is done\n");
        phase2_proxy.send_to_2d();
      }
      when phase2_complete() serial{
        CkPrintf("[PMATRIX] data back to original distirbution\n");
        end = CmiWallTimer();
        CkPrintf("[CONTROLLER] P formed in G space @%f (%f elapsed)\n", end, end - start);
      }
      serial{
        CkPrintf("[CONTROLLER] Exiting, waiting for phase3 to be implemented\n");
        CkExit();
      }

      // FFT P from RSpace to GSpace
      serial {
        start = CmiWallTimer();
        CkPrintf("[CONTROLLER] FFT beginning @%f\n", start);
        pmatrix_proxy.fftRows(1);
      }
      when fftComplete()        serial { pmatrix_proxy.doTranspose(); }
      when transposeComplete()  serial { pmatrix_proxy.fftRows(-1); }
      when fftComplete()        serial { pmatrix_proxy.doTranspose(); }

      when transposeComplete()  serial {
        end = CmiWallTimer();
        CkPrintf("[CONTROLLER] P formed in G space @%f (%f elapsed).\n", end, end - start);
      }
      if (do_output) {
        serial { pmatrix_proxy.printRows(4, "P_Gspace"); }
        when printingComplete() {}
      }
      serial { CkExit(); }
    }
  };

  group FFTController {
    entry FFTController();
  };

  // Caches psis locally on each node so they can be reused when forming P
  nodegroup PsiCache {
    entry PsiCache();
    entry [exclusive] void receivePsi(PsiMessage*);
    entry [exclusive] void computeFs(PsiMessage*);
    //entry void computeF(unsigned int, unsigned int, unsigned int);
  };
};

module states {
  readonly CProxy_States states_proxy;

  // An array containing all of the states in the system. After reading in the
  // states and performing an initial FFT it waits for the controller to tell it
  // where and when to send its data.
  array [3D] States {
    entry States();
    entry void fftGtoR();
    entry [reductiontarget] void sendToCache();
    entry [reductiontarget] void sendToComputeF();
  };  
};

module pmatrix {
  include "ckcomplex.h";
  extern module messages;
  readonly CProxy_PMatrix pmatrix_proxy;

#define IDX(r,c) ((r)*num_cols + (c))

  // An array containing a distributed representation of P. Each time it
  // receives a psi, it multiplies that psi against cached psis to incrementally
  // compute its values.
  array [2D] PMatrix {
    entry PMatrix();
    entry [reductiontarget] void applyFs();
    entry void fftRows(int);
    entry [nokeep] void receiveTransposeData(TransposeMessage*);
    entry void printRows(int n, char prefix[16]);

    entry void doTranspose() {
      serial {
        // TODO: this only works when every chare has same amount of rows
        // TODO: this only works with 1D decomp right now
        TransposeMessage* msg;
        unsigned my_start, their_start;
        unsigned ndata = num_rows * num_rows;

        // Create, fill, and send a transpose message for each chare
        for (int dest = 0; dest < num_chares; dest++) {
          my_start = num_rows * dest;
          their_start = start_row;

          msg = new (ndata) TransposeMessage();
          msg->start_col = their_start;
          for (int c = 0; c < num_rows; c++) {
            for (int r = 0; r < num_rows; r++) {
              // The data is transposed on the sender side
              msg->data[c*num_rows + r] = data[IDX(r,c+my_start)];
            }
          }
          thisProxy(dest,0).receiveTransposeData(msg);
        }
      }

      // Wait to receive the TransposeMessage from every other chare
      for (trans_count = 0; trans_count < num_chares; trans_count++) {
        when receiveTransposeData(TransposeMessage* msg) serial {
          for (int r = 0; r < num_rows; r++) {
            for (int c = 0; c < num_rows; c++) {
              // The data being sent was already transposed on the sender side
              data[IDX(r,c + msg->start_col)] = msg->data[r*num_rows + c];
            }
          }
        }
      }

      // Tell the controller that the transpose is complete
      serial {
        contribute(CkCallback(CkReductionTarget(Controller, transposeComplete), controller_proxy));
      }
    }

    entry void send_to_1d(){
      serial {
        int local_mtx_size_x = num_cols;
        int local_mtx_size_y = num_rows;
        int global_x = local_mtx_size_x*thisIndex.x;
        for(unsigned i=0;i<local_mtx_size_y;++i){
          int global_y = local_mtx_size_y*thisIndex.y + i;
          int recievechar = (int) ((double)global_y/local_mtx_size_1d_y);
          Phase2Message* msg;
          msg = new (local_mtx_size_x) Phase2Message();
          msg->global_x = global_x;
          msg->global_y = global_y;
          msg->size = local_mtx_size_x;
          for(unsigned c = 0; c < local_mtx_size_x; ++c){
            msg->data[c] = data[IDX(i,c)];
          }
          // CkPrintf("sending works\n")
          // CkPrintf("message sent (x_glob: %d, y_glob: %d, recieveing_char: %d)\n", global_x, global_y, (int) ((double)global_y/local_mtx_size_1d_y));
          phase2_proxy[recievechar].recieve_row(msg);
        }
      }
    };
    entry void recieve_chunk(Phase2Message *msg){
      serial{
        int local_mtx_size_x = num_cols;
        int local_mtx_size_y = num_rows;        
        int local_y = msg->global_y - thisIndex.y * local_mtx_size_y;
        int local_x = msg->global_x - thisIndex.x * local_mtx_size_x;
        for(unsigned i=0; i<msg->size; ++i){
          data[IDX(local_y, local_x) + i] = msg->data[i];
        }
        recievecounter++;
      }
      serial{
        if(recievecounter == num_rows){
          contribute(CkCallback(CkReductionTarget(Controller, phase2_complete), controller_proxy));
        }
      }
    }

  };
};
